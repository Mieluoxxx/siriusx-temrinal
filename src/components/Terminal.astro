---
---

<div class="terminal-wrapper">
  <div class="terminal-header">
    <div class="terminal-title">
      <span id="terminal-status" class="status-indicator">ğŸ”´</span>
      <span>XTerminal - æœ¬åœ°ç»ˆç«¯</span>
    </div>
    <div class="terminal-controls">
      <button id="reconnect-btn" class="control-btn" title="é‡æ–°è¿æ¥">ğŸ”„</button>
      <button id="clear-btn" class="control-btn" title="æ¸…ç©ºç»ˆç«¯">ğŸ—‘ï¸</button>
    </div>
  </div>
  <div id="terminal-container">
    <div id="terminal"></div>
  </div>
</div>



<script>
  import { Terminal } from '@xterm/xterm';
  import { FitAddon } from '@xterm/addon-fit';
  import { WebLinksAddon } from '@xterm/addon-web-links';
  import '@xterm/xterm/css/xterm.css';

  // å…¨å±€å˜é‡
  let terminal = null;
  let websocket = null;
  let fitAddon = null;
  let isConnected = false;

  // ç­‰å¾…DOMåŠ è½½å®Œæˆ
  document.addEventListener('DOMContentLoaded', () => {
    initializeTerminal();
    setupEventListeners();
  });

  function initializeTerminal() {
    const terminalElement = document.getElementById('terminal');
    if (!terminalElement) return;

    // åˆ›å»ºç»ˆç«¯å®ä¾‹
    terminal = new Terminal({
      cursorBlink: true,
      theme: {
        background: '#000000',
        foreground: '#ffffff',
        cursor: '#ffffff',
        selection: '#3e4451',
        black: '#000000',
        red: '#e06c75',
        green: '#98c379',
        yellow: '#e5c07b',
        blue: '#61afef',
        magenta: '#c678dd',
        cyan: '#56b6c2',
        white: '#ffffff',
        brightBlack: '#5c6370',
        brightRed: '#e06c75',
        brightGreen: '#98c379',
        brightYellow: '#e5c07b',
        brightBlue: '#61afef',
        brightMagenta: '#c678dd',
        brightCyan: '#56b6c2',
        brightWhite: '#ffffff'
      },
      fontFamily: 'SF Mono, Monaco, Inconsolata, Fira Code, Fira Mono, Roboto Mono, monospace',
      fontSize: 14,
      letterSpacing: 0.5,
      lineHeight: 1.2,
      rows: 30,
      cols: 80,
      scrollback: 1000,
      allowTransparency: false,
    });

    // åŠ è½½æ’ä»¶
    fitAddon = new FitAddon();
    const webLinksAddon = new WebLinksAddon();
    
    terminal.loadAddon(fitAddon);
    terminal.loadAddon(webLinksAddon);

    // æŒ‚è½½åˆ°DOM
    terminal.open(terminalElement);
    
    // è‡ªé€‚åº”å¤§å°
    setTimeout(() => {
      fitAddon.fit();
    }, 100);

    // è¿æ¥åˆ°WebSocketç»ˆç«¯æœåŠ¡
    connectToTerminal();

    // ç›‘å¬ç»ˆç«¯è¾“å…¥
    terminal.onData((data) => {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
          type: 'input',
          data: data
        }));
      }
    });

    // ç›‘å¬ç»ˆç«¯å¤§å°å˜åŒ–
    terminal.onResize(({ cols, rows }) => {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
          type: 'resize',
          cols: cols,
          rows: rows
        }));
      }
    });
  }

  function connectToTerminal() {
    updateStatus('ğŸ”„', 'è¿æ¥ä¸­...');
    terminal.writeln('\x1b[33mæ­£åœ¨è¿æ¥åˆ°æœ¬åœ°ç»ˆç«¯...\x1b[0m');

    try {
      // è¿æ¥åˆ°WebSocketæœåŠ¡å™¨
      websocket = new WebSocket('ws://localhost:8080/terminal');

      websocket.onopen = () => {
        console.log('âœ… WebSocketè¿æ¥å»ºç«‹æˆåŠŸ');
        updateStatus('ğŸŸ¢', 'å·²è¿æ¥');
        isConnected = true;
      };

      websocket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          
          switch (message.type) {
            case 'output':
              terminal.write(message.data);
              break;
              
            case 'connected':
              terminal.write('\x1b[2J\x1b[H'); // æ¸…å±
              terminal.writeln('\x1b[32mğŸš€ XTerminal å·²è¿æ¥åˆ°æœ¬åœ°ç»ˆç«¯\x1b[0m');
              terminal.writeln(`\x1b[36mShell: ${message.shell}\x1b[0m`);
              terminal.writeln(`\x1b[36mPID: ${message.pid}\x1b[0m`);
              terminal.writeln('');
              break;
              
            case 'exit':
              terminal.writeln(`\x1b[31m\nç»ˆç«¯è¿›ç¨‹å·²é€€å‡º (code: ${message.code})\x1b[0m`);
              updateStatus('ğŸ”´', 'å·²æ–­å¼€');
              isConnected = false;
              break;
              
            case 'error':
              terminal.writeln(`\x1b[31mé”™è¯¯: ${message.message}\x1b[0m`);
              updateStatus('ğŸ”´', 'é”™è¯¯');
              isConnected = false;
              break;
              
            default:
              console.warn('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
          }
        } catch (error) {
          console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
        }
      };

      websocket.onerror = (error) => {
        console.error('WebSocketé”™è¯¯:', error);
        terminal.writeln('\x1b[31m\nè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç»ˆç«¯æœåŠ¡æ˜¯å¦å¯åŠ¨\x1b[0m');
        updateStatus('ğŸ”´', 'è¿æ¥é”™è¯¯');
        isConnected = false;
      };

      websocket.onclose = () => {
        console.log('WebSocketè¿æ¥å·²å…³é—­');
        if (isConnected) {
          terminal.writeln('\x1b[31m\nè¿æ¥å·²æ–­å¼€\x1b[0m');
        }
        updateStatus('ğŸ”´', 'å·²æ–­å¼€');
        isConnected = false;
      };

    } catch (error) {
      console.error('è¿æ¥å¤±è´¥:', error);
      terminal.writeln('\x1b[31mè¿æ¥å¤±è´¥ï¼Œè¯·ç¡®ä¿ç»ˆç«¯æœåŠ¡æ­£åœ¨è¿è¡Œ\x1b[0m');
      updateStatus('ğŸ”´', 'è¿æ¥å¤±è´¥');
    }
  }

  function updateStatus(indicator, text) {
    const statusElement = document.getElementById('terminal-status');
    const titleElement = document.querySelector('.terminal-title span:last-child');
    
    if (statusElement) {
      statusElement.textContent = indicator;
    }
    
    if (titleElement) {
      titleElement.textContent = `XTerminal - ${text}`;
    }
  }

  function setupEventListeners() {
    // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°é€‚é…
    window.addEventListener('resize', () => {
      if (fitAddon && terminal) {
        setTimeout(() => {
          fitAddon.fit();
        }, 100);
      }
    });

    // é‡æ–°è¿æ¥æŒ‰é’®
    document.getElementById('reconnect-btn')?.addEventListener('click', () => {
      if (websocket) {
        websocket.close();
      }
      setTimeout(() => {
        connectToTerminal();
      }, 500);
    });

    // æ¸…ç©ºç»ˆç«¯æŒ‰é’®
    document.getElementById('clear-btn')?.addEventListener('click', () => {
      if (terminal) {
        terminal.clear();
      }
    });

    // é¡µé¢å¸è½½æ—¶å…³é—­è¿æ¥
    window.addEventListener('beforeunload', () => {
      if (websocket) {
        websocket.close();
      }
    });
  }
</script>
